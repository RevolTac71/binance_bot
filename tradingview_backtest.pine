// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š VWAP V15.2 (3ë¶„ë´‰ ìµœì í™” & ë™ì  ATR ì ìš© ì™„ë£Œ)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//@version=6
strategy("VWAP V15.2 ìŠ¤ìº˜í•‘ ë©€í‹°", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=10, initial_capital=1000, commission_type=strategy.commission.percent, commission_value=0.04, slippage=1)

// â”€â”€â”€ ì…ë ¥ íŒŒë¼ë¯¸í„° â”€â”€â”€
k_value = input.float(2.0, "K-Value (VWAP ë°´ë“œ)", step=0.1)

rsi_len = input.int(14, "RSI ê¸°ê°„")
rsi_ob  = input.int(70, "RSI ê³¼ë§¤ìˆ˜")
rsi_os  = input.int(30, "RSI ê³¼ë§¤ë„")

vol_sma_len = input.int(20, "Volume SMA ê¸°ê°„")
vol_mult    = input.float(1.5, "Volume Spike ë°°ìˆ˜", step=0.1)

atr_ratio_mult = input.float(1.2, "ë™ì  ë³€ë™ì„± ëŒíŒŒ ë¹„ìœ¨ (ì¥ê¸° ëŒ€ë¹„ ë‹¨ê¸° ATR ë°°ìˆ˜)", step=0.1)
atr_long_len   = input.int(200, "ì¥ê¸° ATR ê¸°ê°„")

sl_atr_mult = input.float(1.5, "SL ìŠ¤íƒ‘ ê±°ë¦¬ (ATR ë°°ìˆ˜)")
tp_atr_mult = input.float(2.5, "TP ìµì ˆ ëª©í‘œ (ATR ë°°ìˆ˜)")

true_risk_pct = input.float(0.5, "1íšŒ ê±°ë˜ ê°ìˆ˜ ë¦¬ìŠ¤í¬(%)", step=0.1) / 100

use_time_exit = input.bool(true, "íƒ€ì„ ì—‘ì‹œíŠ¸ í™œì„±í™”")
time_exit_bars = input.int(30, "íƒ€ì„ ì—‘ì‹œíŠ¸ í•œê³„ë´‰ ìˆ˜ (3ë¶„ë´‰ ê¸°ì¤€ 30ë´‰=90ë¶„)")

leverage = input.int(5, "ìµœëŒ€ í—ˆìš© ë ˆë²„ë¦¬ì§€ ìº¡")

// â”€â”€â”€ ì§€í‘œ ê³„ì‚° â”€â”€â”€
atr_val = ta.atr(14)
rsi_val = ta.rsi(close, rsi_len)
vol_sma = ta.sma(volume, vol_sma_len)

// â”€â”€â”€ ë‹¹ì¼ ëˆ„ì  VWAP (Anchored VWAP) â”€â”€â”€
isNewDay = ta.change(time("D")) != 0

var float sum_pv = 0.0
var float sum_v  = 0.0
var float sum_pv2 = 0.0

typ_price = hlc3 
vol = volume

if isNewDay
    sum_pv  := typ_price * vol
    sum_v   := vol
    sum_pv2 := math.pow(typ_price, 2) * vol
else
    sum_pv  += typ_price * vol
    sum_v   += vol
    sum_pv2 += math.pow(typ_price, 2) * vol

vwap_val = sum_v > 0 ? sum_pv / sum_v : close
variance = sum_v > 0 ? (sum_pv2 / sum_v) - math.pow(vwap_val, 2) : 0
std_dev  = variance > 0 ? math.sqrt(variance) : 0

upper_band = vwap_val + (std_dev * k_value)
lower_band = vwap_val - (std_dev * k_value)

// â”€â”€â”€ Session Filter (ì´ˆê¸°í™” í›„ ë…¸ì´ì¦ˆ ë°©ì§€) â”€â”€â”€
var int bars_since_reset = 0
if isNewDay
    bars_since_reset := 0
else
    bars_since_reset += 1

is_session_safe = bars_since_reset >= 30

// â”€â”€â”€ ë™ì  ë³€ë™ì„± & ê±°ë˜ëŸ‰ í•„í„° â”€â”€â”€
atr_long = ta.atr(atr_long_len)
is_volatile = atr_val > (atr_long * atr_ratio_mult)

// ì‚­ì œë˜ì—ˆë˜ ê±°ë˜ëŸ‰ ìŠ¤íŒŒì´í¬ ë³€ìˆ˜ ë³µêµ¬
is_vol_spike = volume > (vol_sma * vol_mult)
is_extreme_vol = volume > (vol_sma * 2.5)

// â”€â”€â”€ ê°€ê²© ë¦¬ì ì…˜ ë¡œì§ â”€â”€â”€
long_rejection = (low <= lower_band) and (close > lower_band)
short_rejection = (high >= upper_band) and (close < upper_band)

// ì§„ì… íŠ¸ë¦¬ê±° ì¡°í•© (ëª…í™•í•œ ê´„í˜¸ ì²˜ë¦¬)
long_signal = is_session_safe and is_volatile and (rsi_val <= rsi_os) and ((is_vol_spike and long_rejection) or (is_extreme_vol and low <= lower_band))
short_signal = is_session_safe and is_volatile and (rsi_val >= rsi_ob) and ((is_vol_spike and short_rejection) or (is_extreme_vol and high >= upper_band))

// â”€â”€â”€ ATR ê¸°ë°˜ ë™ì  ì‚¬ì´ì¦ˆ ì‚°ì¶œ (ë³µë¦¬ & ë¦¬ìŠ¤í¬ íŒ¨ë¦¬í‹°) â”€â”€â”€
risk_amount = strategy.equity * true_risk_pct
sl_dist = atr_val * sl_atr_mult
tp_dist = atr_val * tp_atr_mult

target_qty = sl_dist > 0 ? (risk_amount / sl_dist) : 0
max_notional = strategy.equity * leverage
trade_qty = math.min(target_qty, close > 0 ? max_notional / close : 0)

// â”€â”€â”€ í¬ì§€ì…˜ ì§„ì… ë° TP/SL ì§€ì •ê°€ ì„¸íŒ… â”€â”€â”€
if long_signal and strategy.position_size == 0
    strategy.entry("Long", strategy.long, qty=trade_qty)
    tp_lvl = close + tp_dist
    sl_lvl = close - sl_dist
    strategy.exit("Exit L", "Long", limit=tp_lvl, stop=sl_lvl)

if short_signal and strategy.position_size == 0
    strategy.entry("Short", strategy.short, qty=trade_qty)
    tp_lvl = close - tp_dist
    sl_lvl = close + sl_dist
    strategy.exit("Exit S", "Short", limit=tp_lvl, stop=sl_lvl)

// â”€â”€â”€ íƒ€ì„ ì—‘ì‹œíŠ¸ ë°©ì–´ë§‰ (Logical Exit) â”€â”€â”€
var int bars_in_pos = 0
if strategy.position_size != 0
    bars_in_pos += 1
else
    bars_in_pos := 0

if use_time_exit and strategy.position_size > 0 and bars_in_pos >= time_exit_bars
    strategy.close("Long", comment="Time Exit (Long)")
if use_time_exit and strategy.position_size < 0 and bars_in_pos >= time_exit_bars
    strategy.close("Short", comment="Time Exit (Short)")

// â”€â”€â”€ ì‹œê°í™” êµ¬ì—­ â”€â”€â”€
plot(vwap_val, title="VWAP", color=color.purple, linewidth=2)
p_upper = plot(upper_band, title="Upper Band", color=color.new(color.red, 30))
p_lower = plot(lower_band, title="Lower Band", color=color.new(color.lime, 30))
fill(p_upper, p_lower, color=color.new(color.gray, 90), title="VWAP Channel")

plotshape(long_signal and strategy.position_size == 0, style=shape.triangleup, location=location.belowbar, color=color.lime, size=size.small, title="Long Signal")
plotshape(short_signal and strategy.position_size == 0, style=shape.triangledown, location=location.abovebar, color=color.red, size=size.small, title="Short Signal")